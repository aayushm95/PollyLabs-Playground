{"1":["# Polyhedral Representation\n\n<br>\n<center>\n<table>\n<tr>\n<td>\n<center>\n<b>Imperative Program</b>\n</center>\n</td>\n<td>\n</td>\n<td>\n<center>\n<b>Iteration Domain</b>\n</center>\n</tr>\n\n<tr>\n<td>\n```c\nconst int N = 10;\ndouble X[N], Y[N], Z[2*N];\n\nfor (int i = 0; i <= 2*N; ++i)\nS:  Z[i] = 0.;\nfor (int i = 1; i <= N; ++i)\n    for (int j = i; j <= N; ++j)\nT:      Z[i + j] += A[i] * B[j];\n```\n</td>\n<td>\n&nbsp; &nbsp; &nbsp;  <b>\\\\( \\Huge \\\\to \\\\) </b>&nbsp; &nbsp; &nbsp; \n</td>\n<td>\n<center>\n<br>\n\\\\( \\\\{ T[i,j] \\mid 0 < i \\le j < 10; S[i,0] \\mid 0 < i \\le 20 \\\\}\\\\) \n</center>\n<div><img \nsrc='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\nonload='pt_plot_set(this, \"{T[i,j] : 0 < i <= j < 10; S[i,0] : 0 < i <= 20}\")'></div>\n\n</td>\n</tr>\n</table>\n</center>","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h1 id=\"polyhedralrepresentation\">Polyhedral Representation</h1>\n<p><br>\n<center></p>\n<table>\n<tr>\n<td>\n<center>\n<b>Imperative Program</b>\n</center>\n</td>\n<td>\n</td>\n<td>\n<center>\n<b>Iteration Domain</b>\n</center>\n</tr>\n\n<tr>\n<td><pre><code class=\"c language-c\">const int N = 10;\ndouble X[N], Y[N], Z[2*N];\n\nfor (int i = 0; i &lt;= 2*N; ++i)\nS:  Z[i] = 0.;\nfor (int i = 1; i &lt;= N; ++i)\n    for (int j = i; j &lt;= N; ++j)\nT:      Z[i + j] += A[i] * B[j];\n</code></pre>\n</td>\n<td>\n&nbsp; &nbsp; &nbsp;  <b>\\( \\Huge \\to \\) </b>&nbsp; &nbsp; &nbsp; \n</td>\n<td>\n<center>\n<br>\n\\( \\{ T[i,j] \\mid 0 < i \\le j < 10; S[i,0] \\mid 0 < i \\le 20 \\}\\) \n</center>\n<div><img \nsrc='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'\nonload='pt_plot_set(this, \"{T[i,j] : 0 < i <= j < 10; S[i,0] : 0 < i <= 20}\")'></div>\n\n</td>\n</tr>\n</table>\n<p></center></p>\n","markdown"],"2":["## Statement instances\n\nConsider the following code fragment that computes a product of polynomials.\nEach of the polynomials is represented by an array of its coefficients.\n```c\nconst int N = 100;\ndouble X[N], Y[N], Z[2*N];\n\nfor (int i = 0; i <= 2*N; ++i)\nS:  Z[i] = 0.;\nfor (int i = 0; i <= N; ++i)\n    for (int j = 0; j <= N; ++j)\nT:      Z[i + j] += A[i] * B[j];\n```\n\nWe will use labels to refer to statements.\nStatement `S` initializes the elements of `Z` array and the `T` statement computes them.\nStatement `S` is enclosed in a loop and is thus executed \\\\((2\\mathtt{N} + 1)\\\\) times in the\nfollowing order.\n\n* `Z[0] = 0.; /* i = 0 */`\n* `Z[1] = 0.; /* i = 1 */`\n* ...\n* `Z[2*N] = 0. /* i = 2*N */;`\n\nWe refer to individual executions of a statement inside a loop as *statement instances*.\nAn instance can be identified by a statement label and the value of the iterator of the enclosing loop,\nfor example:\n    \n* \\\\(\\mathtt{S}(0)\\\\)\n* \\\\(\\mathtt{S}(1)\\\\)\n* ...\n* \\\\(\\mathtt{S}(2 \\mathtt{N})\\\\)\n\nIf a statement is enclosed in multiple loops, its instances are identified by values of all iterators\nin order of their nesting.\nFor example, statement `T` will have, among others, the instances\n\n* \\\\(\\mathtt{T}(0,0)\\\\) for `Z[0] += A[0] * B[0] /* i = 0, j = 0 */`,\n* \\\\(\\mathtt{T}(0,1)\\\\) for `Z[1] += A[0] * B[1] /* i = 0, j = 1 */`,\n* ...\n* \\\\(\\mathtt{T}(\\mathtt{N},\\mathtt{N})\\\\) for `Z[2*N] += A[N] * B[N] /* i = N, j = N */`.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"statementinstances\">Statement instances</h2>\n<p>Consider the following code fragment that computes a product of polynomials.\nEach of the polynomials is represented by an array of its coefficients.</p>\n<pre><code class=\"c language-c\">const int N = 100;\ndouble X[N], Y[N], Z[2*N];\n\nfor (int i = 0; i &lt;= 2*N; ++i)\nS:  Z[i] = 0.;\nfor (int i = 0; i &lt;= N; ++i)\n    for (int j = 0; j &lt;= N; ++j)\nT:      Z[i + j] += A[i] * B[j];\n</code></pre>\n<p>We will use labels to refer to statements.\nStatement <code>S</code> initializes the elements of <code>Z</code> array and the <code>T</code> statement computes them.\nStatement <code>S</code> is enclosed in a loop and is thus executed \\((2\\mathtt{N} + 1)\\) times in the\nfollowing order.</p>\n<ul>\n<li><code>Z[0] = 0.; /* i = 0 */</code></li>\n<li><code>Z[1] = 0.; /* i = 1 */</code></li>\n<li>...</li>\n<li><code>Z[2*N] = 0. /* i = 2*N */;</code></li>\n</ul>\n<p>We refer to individual executions of a statement inside a loop as <em>statement instances</em>.\nAn instance can be identified by a statement label and the value of the iterator of the enclosing loop,\nfor example:</p>\n<ul>\n<li>\\(\\mathtt{S}(0)\\)</li>\n<li>\\(\\mathtt{S}(1)\\)</li>\n<li>...</li>\n<li>\\(\\mathtt{S}(2 \\mathtt{N})\\)</li>\n</ul>\n<p>If a statement is enclosed in multiple loops, its instances are identified by values of all iterators\nin order of their nesting.\nFor example, statement <code>T</code> will have, among others, the instances</p>\n<ul>\n<li>\\(\\mathtt{T}(0,0)\\) for <code>Z[0] += A[0] * B[0] /* i = 0, j = 0 */</code>,</li>\n<li>\\(\\mathtt{T}(0,1)\\) for <code>Z[1] += A[0] * B[1] /* i = 0, j = 1 */</code>,</li>\n<li>...</li>\n<li>\\(\\mathtt{T}(\\mathtt{N},\\mathtt{N})\\) for <code>Z[2*N] += A[N] * B[N] /* i = N, j = N */</code>.</li>\n</ul>\n","markdown"],"3":["## Iteration domain\nThe set of all instances of a statement is referred to as *(iteration) domain* of a statement.\n\nIteration domains can be expressed using the set-builder notation.\nFor example, \\\\( \\\\mathcal{D}_\\\\mathtt{S} = \\\\{ \\\\mathtt{S}[i] : 0 \\\\leq i \\\\leq \\\\mathtt{N} \\\\}. \\\\)\nThe expression \\\\( 0 \\\\leq i \\\\leq \\\\mathtt{N} \\\\) comes directly from the loop lower (`i=0`) and upper (`i<=N`) bounds.\nThe loop iterates for \\\\(i\\\\) ranging from 0 to \\\\(\\mathtt{N}\\\\) inclusive.\n\nThe set we defined is *named*, i.e. the statement name \\\\( \\\\mathtt{S} \\\\) is mentioned before the\nlist of loop iterator names.\nNote that \\\\( \\\\mathtt{N} \\\\) here is treated as a symbolic constant.\nIn the context of the polyhedal model, such symbolic constants are referred to as *(structure) parameters*.\nParameters are explicitly mentioned in the set description,\n\\\\( \\\\mathcal{D}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\mathtt{S}[i] : 0 \\\\leq i \\\\leq N \\\\} \\\\),\nessentially turning it into a map from the parameter value to a concrete instance of a domain set.\nSuch parametric sets can be defined in *isl* as follows.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"iterationdomain\">Iteration domain</h2>\n<p>The set of all instances of a statement is referred to as <em>(iteration) domain</em> of a statement.</p>\n<p>Iteration domains can be expressed using the set-builder notation.\nFor example, \\( \\mathcal{D}_\\mathtt{S} = \\{ \\mathtt{S}[i] : 0 \\leq i \\leq \\mathtt{N} \\}. \\)\nThe expression \\( 0 \\leq i \\leq \\mathtt{N} \\) comes directly from the loop lower (<code>i=0</code>) and upper (<code>i&lt;=N</code>) bounds.\nThe loop iterates for \\(i\\) ranging from 0 to \\(\\mathtt{N}\\) inclusive.</p>\n<p>The set we defined is <em>named</em>, i.e. the statement name \\( \\mathtt{S} \\) is mentioned before the\nlist of loop iterator names.\nNote that \\( \\mathtt{N} \\) here is treated as a symbolic constant.\nIn the context of the polyhedal model, such symbolic constants are referred to as <em>(structure) parameters</em>.\nParameters are explicitly mentioned in the set description,\n\\( \\mathcal{D}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}[i] : 0 \\leq i \\leq N \\} \\),\nessentially turning it into a map from the parameter value to a concrete instance of a domain set.\nSuch parametric sets can be defined in <em>isl</em> as follows.</p>\n","markdown"],"4":["D_S = isl.set(\"[N] -> {S[i]: 0 <= i <= N}\")\nprint_latex(D_S)","\\[N \\to \\{\\, \\mathrm{S}(i) \\mid 0 \\le i \\le N \\,\\}\\]\n","python"],"5":["### \nSimilarly, we can define the iteration domain of the statement `T`,\n\\\\( \\\\mathcal{D}_\\\\mathcal{T} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{T}(i,j) : 0 \\leq i,j \\leq N \\\\} \\\\).\n\nThis domain is defined as a set of two-dimensional vectors.\nEach component of a vector corresponds to an enclosing loop, in nesting order.\n\n### Question\nDefine the variable `D_T` so that it contains the iteration domain of `T` using *isl* notation, then print it.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Similarly, we can define the iteration domain of the statement <code>T</code>,\n\\( \\mathcal{D}_\\mathcal{T} = [N] \\rightarrow \\{ \\mathtt{T}(i,j) : 0 \\leq i,j \\leq N \\} \\).</p>\n<p>This domain is defined as a set of two-dimensional vectors.\nEach component of a vector corresponds to an enclosing loop, in nesting order.</p>\n<h3 id=\"question\">Question</h3>\n<p>Define the variable <code>D_T</code> so that it contains the iteration domain of <code>T</code> using <em>isl</em> notation, then print it.</p>\n","markdown"],"6":["#!Solution\nD_T = isl.set(\"[N] -> {T[i,j]: 0 <= i,j <= N}\")\nprint_latex(D_T)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_T = isl.set(\"[N] -> {T[i,j]: 0 <= i,j <= N}\")\nprint_latex(D_T)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"7":["","","python"],"8":["### \nAs you may see, *isl* output uses conjunction (logical *and*) to combine inequalities around different iterators.\nThis can be handy if the loop bounds differ.  Use `and` in *isl* syntax to express conjunction.\n\n### Question\nRe-define `D_T` using `and` operator to separate bounds on `i` and `j`.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>As you may see, <em>isl</em> output uses conjunction (logical <em>and</em>) to combine inequalities around different iterators.\nThis can be handy if the loop bounds differ.  Use <code>and</code> in <em>isl</em> syntax to express conjunction.</p>\n<h3 id=\"question\">Question</h3>\n<p>Re-define <code>D_T</code> using <code>and</code> operator to separate bounds on <code>i</code> and <code>j</code>.</p>\n","markdown"],"9":["#!Solution\nD_T = isl.set(\"[N] -> {T[i,j]: 0 <= i <= N and 0 <= j <= N}\")\nprint_latex(D_T)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_T = isl.set(\"[N] -> {T[i,j]: 0 <= i <= N and 0 <= j <= N}\")\nprint_latex(D_T)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"10":["","","python"],"11":["### \nIf you already have an *isl* set, you can print it to see the expected syntax.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>If you already have an <em>isl</em> set, you can print it to see the expected syntax.</p>\n","markdown"],"12":["print(D_S)","[N] -> { S[i] : 0 <= i <= N }\n","python"],"13":["### Question\nPrint `D_T` and see whether the output corresponds to your definition.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Print <code>D_T</code> and see whether the output corresponds to your definition.</p>\n","markdown"],"14":["#!Solution\nprint(D_T)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nprint(D_T)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"15":["","","python"],"16":["### \nNote that the output does not necessarily reproduce the textual form of the input.\nRather, it represents the same set after simplification.\nIn particular, redundant inequalities are eliminated and components that appear in first positions are expressed using simpler equations.\nHere is an example of the simplification result.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Note that the output does not necessarily reproduce the textual form of the input.\nRather, it represents the same set after simplification.\nIn particular, redundant inequalities are eliminated and components that appear in first positions are expressed using simpler equations.\nHere is an example of the simplification result.</p>\n","markdown"],"17":["print(isl.set(\"{[i,j]: i+j >= 0 and i >= 0 and j > 0 and j >= 1}\"))","{ [i, j] : i >= 0 and j > 0 and j >= -i }\n","python"],"18":["## Handling Non-Unit Strides\nConsider now the following code snippet that negates every odd element in the array.\n```\nconst int N;\ndouble A[2*N];\n\nfor (int i = 1; i < 2*N; i += 2)\nR:  A[i] = -A[i];\n```\nIf `A` stores real and imaginary parts of complex numbers, one after other, this operation computes a complex conjugate.\n\nThe iteration domain of `R` should now be restricted to odd values of `i`.\nThis can be achieved using a modulo operator\n\\\\( \\\\mathcal{D}_\\\\mathtt{R}: [N] \\\\\\\\rightarrow \\\\{ [i] : 0 \\\\leq i < N \\wedge i\\\\mod 2 = 1 \\\\} \\\\),\nwhich can be translated directly into *isl* syntax.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"handlingnonunitstrides\">Handling Non-Unit Strides</h2>\n<p>Consider now the following code snippet that negates every odd element in the array.</p>\n<pre><code>const int N;\ndouble A[2*N];\n\nfor (int i = 1; i &lt; 2*N; i += 2)\nR:  A[i] = -A[i];\n</code></pre>\n<p>If <code>A</code> stores real and imaginary parts of complex numbers, one after other, this operation computes a complex conjugate.</p>\n<p>The iteration domain of <code>R</code> should now be restricted to odd values of <code>i</code>.\nThis can be achieved using a modulo operator\n\\( \\mathcal{D}_\\mathtt{R}: [N] \\rightarrow \\{ [i] : 0 \\leq i &lt; N \\wedge i\\mod 2 = 1 \\} \\),\nwhich can be translated directly into <em>isl</em> syntax.</p>\n","markdown"],"19":["D_R = isl.set(\"[N] -> {R[i]: i mod 2 = 1 and 0 <= i < N}\")\nprint_latex(D_R)","\\[N \\to \\{\\, \\mathrm{R}(i) \\mid 2*floor((1 + i)/2) = 1 + i \\wedge 0 \\le i < N \\,\\}\\]\n","python"],"20":["### \nAs you may see, *isl* transforms the modulo operation into division with floor rounding.\nThis transformation is a combination of two properties of the modulo operation\n\n\\\\( a \\\\mod b = c \\\\Leftrightarrow (a + c) \\\\mod b = 0 \\\\),\n\n\\\\( a \\\\mod b \\\\equiv a - b \\\\lfloor a/b \\\\\\\\rfloor \\\\).","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>As you may see, <em>isl</em> transforms the modulo operation into division with floor rounding.\nThis transformation is a combination of two properties of the modulo operation</p>\n<p>\\( a \\mod b = c \\Leftrightarrow (a + c) \\mod b = 0 \\),</p>\n<p>\\( a \\mod b \\equiv a - b \\lfloor a/b \\rfloor \\).</p>\n","markdown"],"21":["### Question\nDefine the set representing the iteration domain of `Q` in the following code, then print it\n```\nconst int N;\ndouble A[2*N];\n\nfor (int i = 1; i < 2*N; i += 2)\nQ:  A[i] = -A[i];\n```","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Define the set representing the iteration domain of <code>Q</code> in the following code, then print it</p>\n<pre><code>const int N;\ndouble A[2*N];\n\nfor (int i = 1; i &lt; 2*N; i += 2)\nQ:  A[i] = -A[i];\n</code></pre>\n","markdown"],"22":["#!Solution\nD_Q = isl.set(\"[N] -> {Q[i]: i mod 2 = 0 and 0 <= i < N}\")\nprint_latex(D_Q)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_Q = isl.set(\"[N] -> {Q[i]: i mod 2 = 0 and 0 <= i < N}\")\nprint_latex(D_Q)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"23":["","","python"],"24":["## Handling Conditions\nConditional constructs inside the loop also limit the iteration domain of the statements they enclose.\nThe complex conjugate computation can also be re-written using a branch inside the unit-stride loop.\n```\nconst int N;\ndouble A[2*N];\n\nfor (int i = 1; i < 2*N; ++i)\n    if (i % 2 == 1)\nP:    A[i] = -A[i];\n```\nThe definition of the iteration domain should also include the constraint imposed by the branches surrounding the statement.\n\n### Question\nDefine the set representing the iteration domain of `P` and print it.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"handlingconditions\">Handling Conditions</h2>\n<p>Conditional constructs inside the loop also limit the iteration domain of the statements they enclose.\nThe complex conjugate computation can also be re-written using a branch inside the unit-stride loop.</p>\n<pre><code>const int N;\ndouble A[2*N];\n\nfor (int i = 1; i &lt; 2*N; ++i)\n    if (i % 2 == 1)\nP:    A[i] = -A[i];\n</code></pre>\n<p>The definition of the iteration domain should also include the constraint imposed by the branches surrounding the statement.</p>\n<h3 id=\"question\">Question</h3>\n<p>Define the set representing the iteration domain of <code>P</code> and print it.</p>\n","markdown"],"25":["#!Solution\nD_P = isl.set(\"[N] -> {P[i]: i mod 2 = 1 and 0 <= i < N}\")\nprint_latex(D_P)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_P = isl.set(\"[N] -> {P[i]: i mod 2 = 1 and 0 <= i < N}\")\nprint_latex(D_P)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"26":["","","python"],"27":["### \nEven though the set of statement instances are identical for `P` and `R`, these domains would be considered different *because of different statement names*.\n\n### Question\nWhat do you need to change in the definition of `D_P` to make it equal to `D_R`? \nChange it and check using `D_P.is_equal(D_R)`.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Even though the set of statement instances are identical for <code>P</code> and <code>R</code>, these domains would be considered different <em>because of different statement names</em>.</p>\n<h3 id=\"question\">Question</h3>\n<p>What do you need to change in the definition of <code>D_P</code> to make it equal to <code>D_R</code>? \nChange it and check using <code>D_P.is_equal(D_R)</code>.</p>\n","markdown"],"28":["#!Solution\nD_P = isl.set(\"[N] -> {R[i]: i mod 2 = 1 and 0 <= i < N}\")\nprint(D_P.is_equal(D_R))","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_P = isl.set(\"[N] -> {R[i]: i mod 2 = 1 and 0 <= i < N}\")\nprint(D_P.is_equal(D_R))</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"29":["","","python"],"30":["## Iteration Domains as Presburger Sets\nBecause *isl* operates on Presburger Sets, it can encode any iteration domain that can be expressed using Presburger formulas.\nThis typically involves the statements surrounded by loops and branches with the so called *static control flow*.\nThat is, loop bounds and branch conditions are Presburger formulas of outer loop bounds and parameters.\nThe values of parameters are unknown but must be constant throughout the execution.\nAs a corollary, the control flow cannot depend on *values* being computed.\nHence the program parts amenable to the polyhedral modeling are referred to as *static control parts* or *SCoPs*.\n\n### Question\nDefine the iteration domain of the only statement, enclosed in two loops and a branch with a disjunctive constraint.\n\nHint: use the operator `or` and parentheses to ensure the precedence if necessary.\n```c\nfor (int i = 0; i < 10; ++i)\n  for (int j = 0; j < 10; ++j)\n    if (i < j - 1 || i > j + 1)\n      Z[i][j] = 0.;\n```","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"iterationdomainsaspresburgersets\">Iteration Domains as Presburger Sets</h2>\n<p>Because <em>isl</em> operates on Presburger Sets, it can encode any iteration domain that can be expressed using Presburger formulas.\nThis typically involves the statements surrounded by loops and branches with the so called <em>static control flow</em>.\nThat is, loop bounds and branch conditions are Presburger formulas of outer loop bounds and parameters.\nThe values of parameters are unknown but must be constant throughout the execution.\nAs a corollary, the control flow cannot depend on <em>values</em> being computed.\nHence the program parts amenable to the polyhedral modeling are referred to as <em>static control parts</em> or <em>SCoPs</em>.</p>\n<h3 id=\"question\">Question</h3>\n<p>Define the iteration domain of the only statement, enclosed in two loops and a branch with a disjunctive constraint.</p>\n<p>Hint: use the operator <code>or</code> and parentheses to ensure the precedence if necessary.</p>\n<pre><code class=\"c language-c\">for (int i = 0; i &lt; 10; ++i)\n  for (int j = 0; j &lt; 10; ++j)\n    if (i &lt; j - 1 || i &gt; j + 1)\n      Z[i][j] = 0.;\n</code></pre>\n","markdown"],"31":["#!Solution\nD = isl.set(\"{[i,j]: 0 <= i,j < 10 and (i < j - 1 or i > j + 1)}\")\nprint_latex(D)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD = isl.set(\"{[i,j]: 0 <= i,j < 10 and (i < j - 1 or i > j + 1)}\")\nprint_latex(D)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"32":["","","python"],"33":["### \nIt is also possible to express certain common mathematical operations using the Presburger formulas\n\n* `i >= max(a,b)` \\\\( \\\\Leftrightarrow i \\\\geq a \\wedge i \\\\geq b \\\\) (lower bound only)\n* `i <= min(a,b)` \\\\( \\\\Leftrightarrow i \\\\leq a \\wedge i \\\\leq b \\\\) (upper bound only)\n* `a = ceil(b/c)` \\\\( \\\\Leftrightarrow a = \\\\lfloor (b - 1)/c \\\\\\\\rfloor + 1 \\\\)","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>It is also possible to express certain common mathematical operations using the Presburger formulas</p>\n<ul>\n<li><code>i &gt;= max(a,b)</code> \\( \\Leftrightarrow i \\geq a \\wedge i \\geq b \\) (lower bound only)</li>\n<li><code>i &lt;= min(a,b)</code> \\( \\Leftrightarrow i \\leq a \\wedge i \\leq b \\) (upper bound only)</li>\n<li><code>a = ceil(b/c)</code> \\( \\Leftrightarrow a = \\lfloor (b - 1)/c \\rfloor + 1 \\)</li>\n</ul>\n","markdown"],"34":["## Putting Domains Together\nIn summary, an iteration domain of a statement is a set of multidimensional vectors constrained by the affine expressions that appear in loop bounds and branch conditions surrounding the statement.\n\nIteration domains of multiple statements live in different *spaces* due to different statement names, even if they are enclosed by the same loops.\nThey can be managed together by putting them into a union set.  For example, the combined domain of\n```c\nfor (int i = 0; i < 10; ++i)\n  for (int j = 0; j < 10; ++j) {\n    if (i < j - 1)\nS1:   Z[i][j] = 0.;\n    if (i > j + 1)\nS2:   Z[i][j] = 0.;\n  }\n```\nis defined as\n\\\\( \\\\mathcal{D} = \n    \\\\{\\\\mathtt{S1}[i,j]: 0 \\leq i,j < 10 \\wedge i < j - 1 \\\\} \\cup \n    \\\\{\\\\mathtt{S2}[i,j]: 0 \\leq i,j < 10 \\wedge i > j + 1 \\\\},\n\\\\)\nwhich translates to *isl* notation as","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"puttingdomainstogether\">Putting Domains Together</h2>\n<p>In summary, an iteration domain of a statement is a set of multidimensional vectors constrained by the affine expressions that appear in loop bounds and branch conditions surrounding the statement.</p>\n<p>Iteration domains of multiple statements live in different <em>spaces</em> due to different statement names, even if they are enclosed by the same loops.\nThey can be managed together by putting them into a union set.  For example, the combined domain of</p>\n<pre><code class=\"c language-c\">for (int i = 0; i &lt; 10; ++i)\n  for (int j = 0; j &lt; 10; ++j) {\n    if (i &lt; j - 1)\nS1:   Z[i][j] = 0.;\n    if (i &gt; j + 1)\nS2:   Z[i][j] = 0.;\n  }\n</code></pre>\n<p>is defined as\n\\( \\mathcal{D} = \n    \\{\\mathtt{S1}[i,j]: 0 \\leq i,j < 10 \\wedge i < j - 1 \\} \\cup \n    \\{\\mathtt{S2}[i,j]: 0 \\leq i,j < 10 \\wedge i > j + 1 \\},\n\\)\nwhich translates to <em>isl</em> notation as</p>\n","markdown"],"35":["D = isl.union_set(\"{S1[i,j]: 0 <= i,j <= 10 and i < j - 1; S2[i,j]: 0 <= i,j <= 10 and i > j + 1}\")\nprint_latex(D)","\\[\\begin{array}{l}\\{\\, \\mathrm{S2}(i, j) \\mid 0 \\le i \\le 10 \\wedge 0 \\le j \\le 10 \\wedge j \\le -2 + i \\,\\} \\cup\\\\\\quad\\cup \\{\\, \\mathrm{S1}(i, j) \\mid 0 \\le i \\le 10 \\wedge j \\ge 2 + i \\wedge 0 \\le j \\le 10 \\,\\}\\\\\\end{array}\\]\n","python"],"36":["## Plotting Iteration Domains\nPolyhedral playground supports 1D and 2D plots of non-parametric sets.\nIf the iteration domain has these properties, you can plot it immediately using","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"plottingiterationdomains\">Plotting Iteration Domains</h2>\n<p>Polyhedral playground supports 1D and 2D plots of non-parametric sets.\nIf the iteration domain has these properties, you can plot it immediately using</p>\n","markdown"],"37":["plot(D)","<table class='table table-striped'><thead><tr><th><div class='graphics' id='graphics_495011358123'><img src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' onload='plotUnionSetCombined(\"#graphics_495011358123\",[{\"name\": \"S2\", \"points\": [[2, 0], [3, 0], [3, 1], [4, 0], [4, 1], [4, 2], [5, 0], [5, 1], [5, 2], [5, 3], [6, 0], [6, 1], [6, 2], [6, 3], [6, 4], [7, 0], [7, 1], [7, 2], [7, 3], [7, 4], [7, 5], [8, 0], [8, 1], [8, 2], [8, 3], [8, 4], [8, 5], [8, 6], [9, 0], [9, 1], [9, 2], [9, 3], [9, 4], [9, 5], [9, 6], [9, 7], [10, 0], [10, 1], [10, 2], [10, 3], [10, 4], [10, 5], [10, 6], [10, 7], [10, 8]], \"tiles\": [], \"id\": 5.378973105134475}, {\"name\": \"S1\", \"points\": [[0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [0, 10], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9], [1, 10], [2, 4], [2, 5], [2, 6], [2, 7], [2, 8], [2, 9], [2, 10], [3, 5], [3, 6], [3, 7], [3, 8], [3, 9], [3, 10], [4, 6], [4, 7], [4, 8], [4, 9], [4, 10], [5, 7], [5, 8], [5, 9], [5, 10], [6, 8], [6, 9], [6, 10], [7, 9], [7, 10], [8, 10]], \"tiles\": [], \"id\": 4.661016949152542}],\"#graphics_495011358123\")'></div></th></tr></thead></table>\n","python"],"38":["### \nvisualizations can be useful to see the size of the domain or whether individual domains intersect.\nIn this example, domains are completely disjoint, which means they can be traversed by separate loop nests.\n\nIf the domain is parametric, you will have to first *fix* all parameter values to a constant by\n\n* creating a parametric set where a domain value is fixed;\n* intersecting your domain with this new set; and\n* projecting out the parameters.\n\nHere is how it can be done for `T` statement of our first example.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>visualizations can be useful to see the size of the domain or whether individual domains intersect.\nIn this example, domains are completely disjoint, which means they can be traversed by separate loop nests.</p>\n<p>If the domain is parametric, you will have to first <em>fix</em> all parameter values to a constant by</p>\n<ul>\n<li>creating a parametric set where a domain value is fixed;</li>\n<li>intersecting your domain with this new set; and</li>\n<li>projecting out the parameters.</li>\n</ul>\n<p>Here is how it can be done for <code>T</code> statement of our first example.</p>\n","markdown"],"39":["fixer = isl.set(\"[N] -> {T[i,j]: N = 5}\")\nD_T = D_T.intersect(fixer)\nD_T = D_T.project_out(isl.dim_type.param, 0, 1)\nplot(D_T)","<div class='alert alert-danger' role='alert><span style='color: red'><strong>NameError</strong>: global name 'D_T' is not defined</span><br><span style='color: black; text-decoration: underline; cursor: pointer' onclick='pt_toggleStackTraceVisibility(this)'>Show stack trace</span><div style='display: none; color: black'>Traceback (most recent call last):<br>  File \"c callback\", line 5, in &lt;module&gt;<br>  File \"&lt;string&gt;\", line 2, in &lt;module&gt;<br>NameError: global name 'D_T' is not defined<br></div></div>","error"],"40":["### \nThe `isl.dim_type.param` means that you want to project out parameters, the two following numbers are the\nposition of the first parameter and the number of consecutive parameters that will be projected out.\nFor the sake of plotting, project out all of them. Note that if you forget to fix the parameter size, the set will become unbounded and cannot be plotted.\n\nSimilarly to parameters, you can project out domain dimensions until you get at most two before plotting.\nUse `isl.dim_type.set` to get those.\n\n### Question\nIn the following loop nest performing LU decomposition,\n\n```c\nfor (i = 0; i < N; i++) {\n  for (j = 0; j < i; j++) {\n    for (k = 0; k < j; k++) {\nSa:    A[i][j] -= A[i][k] * A[k][j];\n    }\nSb: A[i][j] /= A[j][j];\n  }\n  for (j = i; j < N; j++) {\n    for (k = 0; k < i; k++) {\nSc:   A[i][j] -= A[i][k] * A[k][j];\n    }\n  }\n}\n```\n\n1. Define the union set with all iteration domains.\n1. Check if iteration domains of `Sa` and `Sc` overlap.\n1. Plot projections on the domain on (i,j), (j,k).\n\nHint: it is impossible to project out domain dimensions *directly* from the union set\nbecause it may have sets that live in different spaces.\nHowever, a union set may be constructed from sets, and you can take a union of union sets.\n","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>The <code>isl.dim_type.param</code> means that you want to project out parameters, the two following numbers are the\nposition of the first parameter and the number of consecutive parameters that will be projected out.\nFor the sake of plotting, project out all of them. Note that if you forget to fix the parameter size, the set will become unbounded and cannot be plotted.</p>\n<p>Similarly to parameters, you can project out domain dimensions until you get at most two before plotting.\nUse <code>isl.dim_type.set</code> to get those.</p>\n<h3 id=\"question\">Question</h3>\n<p>In the following loop nest performing LU decomposition,</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; N; i++) {\n  for (j = 0; j &lt; i; j++) {\n    for (k = 0; k &lt; j; k++) {\nSa:    A[i][j] -= A[i][k] * A[k][j];\n    }\nSb: A[i][j] /= A[j][j];\n  }\n  for (j = i; j &lt; N; j++) {\n    for (k = 0; k &lt; i; k++) {\nSc:   A[i][j] -= A[i][k] * A[k][j];\n    }\n  }\n}\n</code></pre>\n<ol>\n<li>Define the union set with all iteration domains.</li>\n<li>Check if iteration domains of <code>Sa</code> and <code>Sc</code> overlap.</li>\n<li>Plot projections on the domain on (i,j), (j,k).</li>\n</ol>\n<p>Hint: it is impossible to project out domain dimensions <em>directly</em> from the union set\nbecause it may have sets that live in different spaces.\nHowever, a union set may be constructed from sets, and you can take a union of union sets.</p>\n","markdown"],"41":["#!Solution\nD_Sa = isl.set(\"[N] -> {Sa[i,j,k]: 0 <= i < N and 0 <= j < i and 0 <= k < j}\") \nD_Sb = isl.set(\"[N] -> {Sb[i,j]: 0 <= i < N and 0 <= j < i}\")\nD_Sc = isl.set(\"[N] -> {Sc[i,j,k]: 0 <= i < N and i <= j < N and 0 <= k < i}\")\nD = isl.union_set(D_Sa).union(D_Sb).union(D_Sc)\nprint_latex(D)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_Sa = isl.set(\"[N] -> {Sa[i,j,k]: 0 <= i < N and 0 <= j < i and 0 <= k < j}\") \nD_Sb = isl.set(\"[N] -> {Sb[i,j]: 0 <= i < N and 0 <= j < i}\")\nD_Sc = isl.set(\"[N] -> {Sc[i,j,k]: 0 <= i < N and i <= j < N and 0 <= k < i}\")\nD = isl.union_set(D_Sa).union(D_Sb).union(D_Sc)\nprint_latex(D)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"42":["","","python"],"43":["#!Solution\nD_Sa_notag = isl.set(\"[N] -> {[i,j,k]: 0 <= i < N and 0 <= j < i and 0 <= k < j}\") \nD_Sc_notag = isl.set(\"[N] -> {[i,j,k]: 0 <= i < N and i <= j < N and 0 <= k < i}\")\nprint not D_Sa_notag.intersect(D_Sc_notag).is_empty()","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_Sa_notag = isl.set(\"[N] -> {[i,j,k]: 0 <= i < N and 0 <= j < i and 0 <= k < j}\") \nD_Sc_notag = isl.set(\"[N] -> {[i,j,k]: 0 <= i < N and i <= j < N and 0 <= k < i}\")\nprint not D_Sa_notag.intersect(D_Sc_notag).is_empty()</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"44":["","","python"],"45":["#!Solution\nD_Sa = D_Sa.intersect(isl.set(\"[N] -> {Sa[i,j,k]: N = 8}\"))\nD_Sb = D_Sb.intersect(isl.set(\"[N] -> {Sb[i,j]: N = 8}\"))\nD_Sc = D_Sc.intersect(isl.set(\"[N] -> {Sc[i,j,k]: N = 8}\"))\nD_Sa = D_Sa.project_out(isl.dim_type.param, 0, 1)\nD_Sb = D_Sb.project_out(isl.dim_type.param, 0, 1)\nD_Sc = D_Sc.project_out(isl.dim_type.param, 0, 1)\nD_Sa = D_Sa.project_out(isl.dim_type.set, 2, 1)\nD_Sc = D_Sc.project_out(isl.dim_type.set, 2, 1)\nD = isl.union_set(D_Sa).union(D_Sb).union(D_Sc)\nplot(D)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_Sa = D_Sa.intersect(isl.set(\"[N] -> {Sa[i,j,k]: N = 8}\"))\nD_Sb = D_Sb.intersect(isl.set(\"[N] -> {Sb[i,j]: N = 8}\"))\nD_Sc = D_Sc.intersect(isl.set(\"[N] -> {Sc[i,j,k]: N = 8}\"))\nD_Sa = D_Sa.project_out(isl.dim_type.param, 0, 1)\nD_Sb = D_Sb.project_out(isl.dim_type.param, 0, 1)\nD_Sc = D_Sc.project_out(isl.dim_type.param, 0, 1)\nD_Sa = D_Sa.project_out(isl.dim_type.set, 2, 1)\nD_Sc = D_Sc.project_out(isl.dim_type.set, 2, 1)\nD = isl.union_set(D_Sa).union(D_Sb).union(D_Sc)\nplot(D)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"46":["","","python"],"47":["","",""]}