{"1":["# Schedules\n\n<br>\n<center>\n<p style=\"font-size: 3em\">\n\n\\\\( \\\\{ (i,j,k) \\\\to \\\\) <span class=\"glyphicon glyphicon-time\"></span> \\\\( (i+j, k, i) \\\\} \\\\)\n</p>\n</center>","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h1 id=\"schedules\">Schedules</h1>\n<p><br>\n<center></p>\n<p style=\"font-size: 3em\">\n\n\\( \\{ (i,j,k) \\to \\) <span class=\"glyphicon glyphicon-time\"></span> \\( (i+j, k, i) \\} \\)\n</p>\n<p></center></p>\n","markdown"],"2":["## Definition\nThe iteration domain of statements gives information about the *instances* to be executed but does not specify in which order.\nIn fact, we can specify any piece-wise quasi-linear order by assigning logical execution dates to each statement instance.\nConcisely, this *schedule* can be expressed as a Presburger map between statement instances and logical dates.\n\n## Identity Schedule\nBy default, statement instances are executed following the loop iteration order.\nThis can be expressed using an *identity* schedule relation.\n\nFor example, the simple initialization loop\n```c\nfor (i = 0; i < N; ++i)\nS:  A[i] = 0.0;\n```\nwith iteration domain\n\\\\( \\\\mathcal{D}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{S}(i) : 0 \\\\leq i < N \\\\} \\\\)\ncan have an identity schedule\n\\\\( \\\\mathcal{T}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{S}(i) \\\\\\\\rightarrow (t\\_0) : t\\_0 = i \\\\} \\\\).\n\nIn *isl* notation, this is expressed as","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"definition\">Definition</h2>\n<p>The iteration domain of statements gives information about the <em>instances</em> to be executed but does not specify in which order.\nIn fact, we can specify any piece-wise quasi-linear order by assigning logical execution dates to each statement instance.\nConcisely, this <em>schedule</em> can be expressed as a Presburger map between statement instances and logical dates.</p>\n<h2 id=\"identityschedule\">Identity Schedule</h2>\n<p>By default, statement instances are executed following the loop iteration order.\nThis can be expressed using an <em>identity</em> schedule relation.</p>\n<p>For example, the simple initialization loop</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; N; ++i)\nS:  A[i] = 0.0;\n</code></pre>\n<p>with iteration domain\n\\( \\mathcal{D}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}(i) : 0 \\leq i &lt; N \\} \\)\ncan have an identity schedule\n\\( \\mathcal{T}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}(i) \\rightarrow (t_0) : t_0 = i \\} \\).</p>\n<p>In <em>isl</em> notation, this is expressed as</p>\n","markdown"],"3":["D_S = isl.set(\"[N] -> {S[i]: 0 <= i < N}\")\nT_S = isl.map(\"[N] -> {S[i] -> [t0]: t0 = i}\")\nprint_latex(T_S)","\\[N \\to \\{\\, \\mathrm{S}(i) \\to t0 = i \\,\\}\\]\n","python"],"4":["## Multidimensional Schedules\nIf a statement instance is identified by a vector of more than one element, i.e. the statement is enclosed in multiple nested loops,\nit is usually mapped to a *multidimensional* logical dates.\nIn this case, the statement instances are executed following the *lexicographical order* of their logical dates.\nFor example, the date \\\\((0,42)\\\\) precedes the date \\\\((100,0)\\\\).  We denote this as \\\\((0,42) \\\\prec (100,0)\\\\).\nThe lexicographical order is usually extended to compare vectors of different size.\nA shorter vector that is a prefix of a longer vector precedes it, for example \\\\((0,42) \\\\prec (0,42,0)\\\\).\n\nFor example, zero-initialization of a two-dimensional array\n```c\nfor (i = 0; i < N; ++i)\n  for (j = 0; j < N; ++j)\nS:  A[i][j] = 0.0;\n```\nhas the iteration domain\n\\\\( \\\\mathcal{D}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{S}(i): 0 \\leq i,j < N \\\\} \\\\)\nwill have the identity schedule\n\\\\( \\\\mathcal{T}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{S}(i,j) \\\\\\\\rightarrow (t\\_0, t\\_1) : t\\_0 = i \\wedge t\\_1 = j \\\\} \\\\).\n\nIn *isl* notation, this is expressed as","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"multidimensionalschedules\">Multidimensional Schedules</h2>\n<p>If a statement instance is identified by a vector of more than one element, i.e. the statement is enclosed in multiple nested loops,\nit is usually mapped to a <em>multidimensional</em> logical dates.\nIn this case, the statement instances are executed following the <em>lexicographical order</em> of their logical dates.\nFor example, the date \\((0,42)\\) precedes the date \\((100,0)\\).  We denote this as \\((0,42) \\prec (100,0)\\).\nThe lexicographical order is usually extended to compare vectors of different size.\nA shorter vector that is a prefix of a longer vector precedes it, for example \\((0,42) \\prec (0,42,0)\\).</p>\n<p>For example, zero-initialization of a two-dimensional array</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; N; ++i)\n  for (j = 0; j &lt; N; ++j)\nS:  A[i][j] = 0.0;\n</code></pre>\n<p>has the iteration domain\n\\( \\mathcal{D}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}(i): 0 \\leq i,j &lt; N \\} \\)\nwill have the identity schedule\n\\( \\mathcal{T}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}(i,j) \\rightarrow (t_0, t_1) : t_0 = i \\wedge t_1 = j \\} \\).</p>\n<p>In <em>isl</em> notation, this is expressed as</p>\n","markdown"],"5":["D_S = isl.set(\"[N] -> {S[i,j]: 0 <= i,j < N}\")\nT_S = isl.map(\"[N] -> {S[i,j] -> [t0,t1]: t0 = i and t1 = j}\")\nprint_latex(T_S)","\\[N \\to \\{\\, \\mathrm{S}(i, j) \\to (t0 = i, t1 = j) \\,\\}\\]\n","python"],"6":["### \nEven if in theory the schedule can be expressed using a single dimension\n\\\\( \\\\mathcal{T}\\_\\\\mathtt{S} = [N] \\\\\\\\rightarrow \\\\{ \\\\mathtt{S}(i,j) \\\\\\\\rightarrow (t\\_0) : t\\_0 = Ni + j \\\\} \\\\)\nsuch expression cannot be represented as a Presburger map due to multiplication of the variables.\nHowever, such schedules can be constructed when the actual constant is used instead of a constant parameter.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Even if in theory the schedule can be expressed using a single dimension\n\\( \\mathcal{T}_\\mathtt{S} = [N] \\rightarrow \\{ \\mathtt{S}(i,j) \\rightarrow (t_0) : t_0 = Ni + j \\} \\)\nsuch expression cannot be represented as a Presburger map due to multiplication of the variables.\nHowever, such schedules can be constructed when the actual constant is used instead of a constant parameter.</p>\n","markdown"],"7":["### Question\nPropose an identity schedule for the initialization loop of a three-dimensional array\n```c\nfor (i = 0; i < N; ++i)\n  for (j = 0; j < N; ++j)\n    for (k = 0; k < N; ++k)\nT:    A[i][j] = 0.0;\n```","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Propose an identity schedule for the initialization loop of a three-dimensional array</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; N; ++i)\n  for (j = 0; j &lt; N; ++j)\n    for (k = 0; k &lt; N; ++k)\nT:    A[i][j] = 0.0;\n</code></pre>\n","markdown"],"8":["#!Solution\nD_T = isl.set(\"[N] -> {S[i,j,k]: 0 <= i,j,k < N}\")\nT_T = isl.map(\"[N] -> {S[i,j,k] -> [t0,t1,t2]: t0 = i and t1 = j and t2 = k}\")\nprint_latex(T_T)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD_T = isl.set(\"[N] -> {S[i,j,k]: 0 <= i,j,k < N}\")\nT_T = isl.map(\"[N] -> {S[i,j,k] -> [t0,t1,t2]: t0 = i and t1 = j and t2 = k}\")\nprint_latex(T_T)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"9":["","","python"],"10":["### Question\nTry defining a one-dimensional schedule with multiplication for the same domain (error expected).","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Try defining a one-dimensional schedule with multiplication for the same domain (error expected).</p>\n","markdown"],"11":["#!Solution\nT_T_err = isl.map(\"[N] -> {S[i,j,k] -> [t0]: t0 = N*N*i + N*j + k}\")","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nT_T_err = isl.map(\"[N] -> {S[i,j,k] -> [t0]: t0 = N*N*i + N*j + k}\")</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"12":["","","python"],"13":["## Representing Lexical Order\nConsider the loop nest with two statements\n```c\nfor (i = 0; i < 10; ++i) {\nP:  A[i] = 0.0;\nQ:  B[i] = 1.0;\n}\n```\nUsing plain identity schedule for both statement would result in them having *identical* dates.\nYet it is clear from the code that instances of `Q` are executed *after* the respective instances of `P`.\nThis *lexical order* of the statements can be encoded in the schedule relations using an *auxiliary* dimension.\nIt is assigned a constant so as to force instances of `P` to be executed before instances of `Q`,\ni.e. the constant for `P` is smaller than the one for `Q`.\nBecause the order exists *inside* the loop, the auxiliary dimension is placed after the loop dimension.\n\\\\( \\\\mathcal{T} = \n  \\\\{ P(i) \\\\\\\\rightarrow (t\\_0, t\\_1) : t\\_0 = i \\wedge t\\_1 = 0 \\\\} \\\\cup\n  \\\\{ Q(i) \\\\\\\\rightarrow (t\\_0, t\\_1) : t\\_0 = i \\wedge t\\_1 = 1 \\\\} \\\\)\nThis map will assign dates \\\\((i,0)\\\\) to the instances of `P` and dates \\\\((i,1)\\\\) to the instances of `Q`.\nIt is clear that \\\\( \\\\\\\\forall i, (i,0) \\\\prec (i,1) \\\\).\nIn *isl*, schedules for different statements can be combined into a union map.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"representinglexicalorder\">Representing Lexical Order</h2>\n<p>Consider the loop nest with two statements</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; 10; ++i) {\nP:  A[i] = 0.0;\nQ:  B[i] = 1.0;\n}\n</code></pre>\n<p>Using plain identity schedule for both statement would result in them having <em>identical</em> dates.\nYet it is clear from the code that instances of <code>Q</code> are executed <em>after</em> the respective instances of <code>P</code>.\nThis <em>lexical order</em> of the statements can be encoded in the schedule relations using an <em>auxiliary</em> dimension.\nIt is assigned a constant so as to force instances of <code>P</code> to be executed before instances of <code>Q</code>,\ni.e. the constant for <code>P</code> is smaller than the one for <code>Q</code>.\nBecause the order exists <em>inside</em> the loop, the auxiliary dimension is placed after the loop dimension.\n\\( \\mathcal{T} = \n  \\{ P(i) \\rightarrow (t_0, t_1) : t_0 = i \\wedge t_1 = 0 \\} \\cup\n  \\{ Q(i) \\rightarrow (t_0, t_1) : t_0 = i \\wedge t_1 = 1 \\} \\)\nThis map will assign dates \\((i,0)\\) to the instances of <code>P</code> and dates \\((i,1)\\) to the instances of <code>Q</code>.\nIt is clear that \\( \\forall i, (i,0) \\prec (i,1) \\).\nIn <em>isl</em>, schedules for different statements can be combined into a union map.</p>\n","markdown"],"14":["D = isl.union_set(\"{P[i]: 0 <= i < 10; Q[i]: 0 <= i < 10}\")\nS = isl.union_map(\"{P[i] -> [t0,t1]: t0 = i and t1 = 0; Q[i] -> [t0,t1]: t0 = i and t1 = 1}\")\nprint_latex(S)","\\[\\{\\, \\mathrm{P}(i) \\to (t0 = i, t1 = 0) \\,\\} \\cup \\{\\, \\mathrm{Q}(i) \\to (t0 = i, t1 = 1) \\,\\}\\]\n","python"],"15":["### \nConsider the SCoP with two loops\n```c\nfor (i = 0; i < 10; ++i) {\nU:  A[i] = 0.0;\n}\nfor (i = 0; i < 10; ++i) {\nV:  B[i] = 1.0;\n}\n```\nIn this case, *all* instances of `U` are executed before *any* instance of `V`.\nTherefore, the auxiliary dimension is introduced *before* the loop dimension.\n\\\\( \\\\mathcal{T} =\n  \\\\{ \\\\mathtt{U}(i) \\\\\\\\rightarrow (t\\_0, t\\_1) : t\\_0 = 0 \\wedge t\\_1 = i \\\\} \\\\cup\n  \\\\{ \\\\mathtt{V}(i) \\\\\\\\rightarrow (t\\_0, t\\_1) : t\\_0 = 1 \\wedge t\\_1 = i \\\\}.\n\\\\)\nOr, in *isl* notation","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Consider the SCoP with two loops</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; 10; ++i) {\nU:  A[i] = 0.0;\n}\nfor (i = 0; i &lt; 10; ++i) {\nV:  B[i] = 1.0;\n}\n</code></pre>\n<p>In this case, <em>all</em> instances of <code>U</code> are executed before <em>any</em> instance of <code>V</code>.\nTherefore, the auxiliary dimension is introduced <em>before</em> the loop dimension.\n\\( \\mathcal{T} =\n  \\{ \\mathtt{U}(i) \\rightarrow (t_0, t_1) : t_0 = 0 \\wedge t_1 = i \\} \\cup\n  \\{ \\mathtt{V}(i) \\rightarrow (t_0, t_1) : t_0 = 1 \\wedge t_1 = i \\}.\n\\)\nOr, in <em>isl</em> notation</p>\n","markdown"],"16":["D2 = isl.union_set(\"{U[i]: 0 <= i < 10; V[i]: 0 <= i < 10}\")\nS2 = isl.union_map(\"{U[i] -> [t0,t1]: t0 = 0 and t1 = i; V[i] -> [t0,t1]: t0 = 1 and t1 = i}\")\nprint_latex(S2)","\\[\\{\\, \\mathrm{U}(i) \\to (t0 = 0, t1 = i) \\,\\} \\cup \\{\\, \\mathrm{V}(i) \\to (t0 = 1, t1 = i) \\,\\}\\]\n","python"],"17":["### \nPlotting the *scheduled domain* can help to see the difference.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Plotting the <em>scheduled domain</em> can help to see the difference.</p>\n","markdown"],"18":["plot([D.apply(S),D2.apply(S2)])","<table class='table table-striped'><thead><tr><th><div class='graphics' id='graphics_912829062462'><img src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' onload='plotUnionSetCombined(\"#graphics_912829062462\",[{\"name\": \"\", \"points\": [[0, 1], [1, 1], [2, 1], [3, 1], [4, 1], [5, 1], [6, 1], [7, 1], [8, 1], [9, 1], [0, 0], [1, 0], [2, 0], [3, 0], [4, 0], [5, 0], [6, 0], [7, 0], [8, 0], [9, 0]], \"tiles\": [], \"id\": 5.378973105134475}],\"#graphics_912829062462\")'></div></th><th><div class='graphics' id='graphics_135646265887'><img src='data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7' onload='plotUnionSetCombined(\"#graphics_135646265887\",[{\"name\": \"\", \"points\": [[0, 0], [0, 1], [0, 2], [0, 3], [0, 4], [0, 5], [0, 6], [0, 7], [0, 8], [0, 9], [1, 0], [1, 1], [1, 2], [1, 3], [1, 4], [1, 5], [1, 6], [1, 7], [1, 8], [1, 9]], \"tiles\": [], \"id\": 5.378973105134475}],\"#graphics_135646265887\")'></div></th></tr></thead></table>\n","python"],"19":["### \nNote that the logical dates live in the *same* space for all statements, therefore one cannot tell them apart visually.\n\n### Question\nGenerally, an auxiliary dimension is included *after* the last loop the statements share.\nIf they do not share any loop, it comes foremost.\nDefine the identity schedule with auxiliary dimensions for the SCoP.\n```c\nfor (i = 0; i < 10; ++i) {\n  for (j = 0; j < 5; ++j)\nS1: A[i][j] = 0.;\n  for (j = 0; j < 5; ++j)\nS2: B[i][j] = 0.;\n}\n```","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Note that the logical dates live in the <em>same</em> space for all statements, therefore one cannot tell them apart visually.</p>\n<h3 id=\"question\">Question</h3>\n<p>Generally, an auxiliary dimension is included <em>after</em> the last loop the statements share.\nIf they do not share any loop, it comes foremost.\nDefine the identity schedule with auxiliary dimensions for the SCoP.</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; 10; ++i) {\n  for (j = 0; j &lt; 5; ++j)\nS1: A[i][j] = 0.;\n  for (j = 0; j &lt; 5; ++j)\nS2: B[i][j] = 0.;\n}\n</code></pre>\n","markdown"],"20":["#!Solution\nD = isl.union_set(\"{S1[i,j]: 0 <= i < 10 and 0 <= j < 5; S2[i,j]: 0 <= i < 10 and 0 <= j < 5}\")\nS = isl.union_map(\"{S1[i,j] -> [t0,t1,t2]: t0 = i and t1 = 0 and t2 = j; S2[i,j] -> [t0,t1,t2]: t0 = i and t1 = 1 and t2 = j}\")\nprint_latex(S)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nD = isl.union_set(\"{S1[i,j]: 0 <= i < 10 and 0 <= j < 5; S2[i,j]: 0 <= i < 10 and 0 <= j < 5}\")\nS = isl.union_map(\"{S1[i,j] -> [t0,t1,t2]: t0 = i and t1 = 0 and t2 = j; S2[i,j] -> [t0,t1,t2]: t0 = i and t1 = 1 and t2 = j}\")\nprint_latex(S)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"21":["","",""]}