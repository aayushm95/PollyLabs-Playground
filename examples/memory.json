{"1":["# Modeling memory accesses\n\n## Access Relations\nEach statement instance may access one or more variables, scalars or arrays.\nIf the array subscripts are affine forms of loop iterators and structure parameters,\none can define a Presburger relation that associates statement instances to the array elements they access.\nScalars are usually considered as zero-dimensional arrays in the polyhedral model for the sake of consistency.\n\nConsider the polynomial multiplication kernel\n```c\ndouble X[100], Y[100], Z[200];\ndouble zero = 0.;\n\nfor (int i = 0; i <= 200; ++i)\nS:  Z[i] = zero;\nfor (int i = 0; i <= 100; ++i)\n    for (int j = 0; j <= 100; ++j)\nT:      Z[i + j] += A[i] * B[j];\n```\n\nUsing only syntactic terms, we can say that statement `S` accesses array `Z`.\nHowever, each individual *instance* \\\\( \\\\mathtt{S}(i) \\\\) only accesses one array element, `Z[i]`.\nThis can be encoded by a relation \\\\( \\\\{ \\\\mathtt{S}(i) \\\\\\\\rightarrow \\\\mathtt{Z}(a): a = i \\\\} \\\\).\nFurthermore, we know the size of the array `Z` so we can define constraints on \\\\(a\\\\) that avoid out-of-memory accesses,\n\\\\( \\\\{ \\mathtt{Z}(a): 0 \\\\leq a \\\\leq 200 \\\\} \\\\).\nAt the same time, the iteration domain of `S` is\n\\\\( \\\\{ \\mathtt{S}(i): 0 \\\\leq i \\\\leq 200 \\\\} \\\\).\nTo plug these constraints into the access relation, we can intersect its *domain* with the iteration domain and its *range* with the array size constraint set.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h1 id=\"modelingmemoryaccesses\">Modeling memory accesses</h1>\n<h2 id=\"accessrelations\">Access Relations</h2>\n<p>Each statement instance may access one or more variables, scalars or arrays.\nIf the array subscripts are affine forms of loop iterators and structure parameters,\none can define a Presburger relation that associates statement instances to the array elements they access.\nScalars are usually considered as zero-dimensional arrays in the polyhedral model for the sake of consistency.</p>\n<p>Consider the polynomial multiplication kernel</p>\n<pre><code class=\"c language-c\">double X[100], Y[100], Z[200];\ndouble zero = 0.;\n\nfor (int i = 0; i &lt;= 200; ++i)\nS:  Z[i] = zero;\nfor (int i = 0; i &lt;= 100; ++i)\n    for (int j = 0; j &lt;= 100; ++j)\nT:      Z[i + j] += A[i] * B[j];\n</code></pre>\n<p>Using only syntactic terms, we can say that statement <code>S</code> accesses array <code>Z</code>.\nHowever, each individual <em>instance</em> \\( \\mathtt{S}(i) \\) only accesses one array element, <code>Z[i]</code>.\nThis can be encoded by a relation \\( \\{ \\mathtt{S}(i) \\rightarrow \\mathtt{Z}(a): a = i \\} \\).\nFurthermore, we know the size of the array <code>Z</code> so we can define constraints on \\(a\\) that avoid out-of-memory accesses,\n\\( \\{ \\mathtt{Z}(a): 0 \\leq a \\leq 200 \\} \\).\nAt the same time, the iteration domain of <code>S</code> is\n\\( \\{ \\mathtt{S}(i): 0 \\leq i \\leq 200 \\} \\).\nTo plug these constraints into the access relation, we can intersect its <em>domain</em> with the iteration domain and its <em>range</em> with the array size constraint set.</p>\n","markdown"],"2":["A_S_Z = isl.map(\"{S[i] -> Z[a]: a = i}\")\nD_S = isl.set(\"{S[i]: 0 <= i <= 200}\")\nC_Z = isl.set(\"{Z[a]: 0 <= a <= 200}\")\nA_S_Z = A_S_Z.intersect_domain(D_S).intersect_range(C_Z)\nprint_latex(A_S_Z)","\\[\\{\\, \\mathrm{S}(i) \\to \\mathrm{Z}(a = i) \\mid 0 \\le i \\le 200 \\,\\}\\]\n","python"],"3":["### \nThe constraints on \\\\(a\\\\) disappeared because of the *isl* simplification process.\nSince \\\\(a = i\\\\) the constraints hold simultaneously for both \\\\(a\\\\) and \\\\(i\\\\).\n\nScalars do not have subscripts, so they appear as zero-dimensional vectors in the range of access relation.\nHowever, the range still has a name to tell scalars apart.  For example, all instances of `S` access the scalar `zero`,\n\\\\( \\\\{ \\\\mathtt{S}(i) \\\\\\\\rightarrow \\\\mathtt{zero}(): 0 \\\\leq i \\\\leq 200 \\\\} \\\\).\nThe additional constraints on \\\\(i\\\\) come from the iteration domain of `S`.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>The constraints on \\(a\\) disappeared because of the <em>isl</em> simplification process.\nSince \\(a = i\\) the constraints hold simultaneously for both \\(a\\) and \\(i\\).</p>\n<p>Scalars do not have subscripts, so they appear as zero-dimensional vectors in the range of access relation.\nHowever, the range still has a name to tell scalars apart.  For example, all instances of <code>S</code> access the scalar <code>zero</code>,\n\\( \\{ \\mathtt{S}(i) \\rightarrow \\mathtt{zero}(): 0 \\leq i \\leq 200 \\} \\).\nThe additional constraints on \\(i\\) come from the iteration domain of <code>S</code>.</p>\n","markdown"],"4":["A_S_zero = isl.map(\"{S[i] -> zero[]:}\")\nA_S_zero = A_S_zero.intersect_domain(D_S)\nprint_latex(A_S_zero)","\\[\\{\\, \\mathrm{S}(i) \\to \\mathrm{zero}() \\mid 0 \\le i \\le 200 \\,\\}\\]\n","python"],"5":["### \nFinally, it is possible to combine the access relations to different arrays into a single union map that describes all accesses of a statement.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Finally, it is possible to combine the access relations to different arrays into a single union map that describes all accesses of a statement.</p>\n","markdown"],"6":["A_S = isl.union_map(A_S_Z).union(A_S_zero)\nprint_latex(A_S)","\\[\\{\\, \\mathrm{S}(i) \\to \\mathrm{Z}(a = i) \\mid 0 \\le i \\le 200 \\,\\} \\cup \\{\\, \\mathrm{S}(i) \\to \\mathrm{zero}() \\mid 0 \\le i \\le 200 \\,\\}\\]\n","python"],"7":["### \nBecause we want to ensure the order of *reads* and *writes*, we can differentiate between access types by defining separate unions of access relations..\nSome relations may appear in both, in case where the statement both reads and writes the same variable.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Because we want to ensure the order of <em>reads</em> and <em>writes</em>, we can differentiate between access types by defining separate unions of access relations..\nSome relations may appear in both, in case where the statement both reads and writes the same variable.</p>\n","markdown"],"8":["### Question\nDefine the map `A_T_Z` that connects instances of the statement `T` to elements of the array `Z`, then print it.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Define the map <code>A_T_Z</code> that connects instances of the statement <code>T</code> to elements of the array <code>Z</code>, then print it.</p>\n","markdown"],"9":["#!Solution\nA_T_Z = isl.map(\"{T[i,j] -> Z[a]: a = i + j}\")\nprint_latex(A_T_Z)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nA_T_Z = isl.map(\"{T[i,j] -> Z[a]: a = i + j}\")\nprint_latex(A_T_Z)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"10":["","",""],"11":["### Question\nDefine the union maps `A_T_reads` and `A_T_writes` that map instances of the statement `T` to elements of *all* arrays they read and write, respectively.  Print them.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Define the union maps <code>A_T_reads</code> and <code>A_T_writes</code> that map instances of the statement <code>T</code> to elements of <em>all</em> arrays they read and write, respectively.  Print them.</p>\n","markdown"],"12":["#!Solution\nA_T_reads = isl.union_map(\"{T[i,j] -> Z[a]: a = i + j; T[i,j] -> X[a]: a = i; T[i,j] -> Y[a]: a = j}\")\nA_T_writes = isl.union_map(\"{T[i,j] -> Z[a]: a = i + j}\")\nprint_latex(A_T_reads)\nprint_latex(A_T_writes)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nA_T_reads = isl.union_map(\"{T[i,j] -> Z[a]: a = i + j; T[i,j] -> X[a]: a = i; T[i,j] -> Y[a]: a = j}\")\nA_T_writes = isl.union_map(\"{T[i,j] -> Z[a]: a = i + j}\")\nprint_latex(A_T_reads)\nprint_latex(A_T_writes)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"13":["","",""],"14":["## Detecting Out-of-Bounds Accesses\nBy combining the iteration domain and the array size sets, one can detect out of bounds accesses.\nConsider the following code\n```c\ndouble A[99];\nfor (int i = 0; i <= 99; i++)\nX:  A[i+1] = 0.;\n```\nThe access relation is based on the equality \\\\( a = i + 1 \\\\).\nWe first intersect its domain with the iteration domain of `S` and then its range with the size constraints on `A`.\nThe resulting relation contains all the *access instances*, i.e. pairs of statement instances and array elements, that are within the array extent.\nSubtracting this relation from the relation only constrained by the domain gives us the relation of *invalid accesses*,\nwhich shows which statement instance accesses which out-of-bounds array element.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"detectingoutofboundsaccesses\">Detecting Out-of-Bounds Accesses</h2>\n<p>By combining the iteration domain and the array size sets, one can detect out of bounds accesses.\nConsider the following code</p>\n<pre><code class=\"c language-c\">double A[99];\nfor (int i = 0; i &lt;= 99; i++)\nX:  A[i+1] = 0.;\n</code></pre>\n<p>The access relation is based on the equality \\( a = i + 1 \\).\nWe first intersect its domain with the iteration domain of <code>S</code> and then its range with the size constraints on <code>A</code>.\nThe resulting relation contains all the <em>access instances</em>, i.e. pairs of statement instances and array elements, that are within the array extent.\nSubtracting this relation from the relation only constrained by the domain gives us the relation of <em>invalid accesses</em>,\nwhich shows which statement instance accesses which out-of-bounds array element.</p>\n","markdown"],"15":["A_X_A = isl.map(\"{X[i]->A[a]: a = i+1}\")\nC_A = isl.set(\"{A[i]: 0 <= i <= 99}\")\nD_X = isl.set(\"{X[i]: 0 <= i <= 99}\")\ncorrect = A_X_A.intersect_domain(D_X).intersect_range(C_A)\nincorrect = A_X_A.intersect_domain(D_X).subtract(correct)\nprint_latex(incorrect)","\\[\\{\\, \\mathrm{X}(i = 99) \\to \\mathrm{A}(a = 100) \\,\\}\\]\n","python"],"16":["### \nIn this case, the instance \\\\(X(99)\\\\) performs a one-past-end access to `A`.\nThis can be fixed, for example, by using strict comparison in the loop upper bound, `i < 99`.\n\n### Question\nVerify that the fix is correct, i.e. that the map of incorrect accesses is empty.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>In this case, the instance \\(X(99)\\) performs a one-past-end access to <code>A</code>.\nThis can be fixed, for example, by using strict comparison in the loop upper bound, <code>i &lt; 99</code>.</p>\n<h3 id=\"question\">Question</h3>\n<p>Verify that the fix is correct, i.e. that the map of incorrect accesses is empty.</p>\n","markdown"],"17":["#!Solution\nA_X_A = isl.map(\"{X[i]->A[a]: a = i+1}\")\nC_A = isl.set(\"{A[i]: 0 <= i <= 99}\")\nD_X = isl.set(\"{X[i]: 0 <= i < 99}\")\ncorrect = A_X_A.intersect_domain(D_X).intersect_range(C_A)\nincorrect = A_X_A.intersect_domain(D_X).subtract(correct)\nprint_latex(incorrect)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nA_X_A = isl.map(\"{X[i]->A[a]: a = i+1}\")\nC_A = isl.set(\"{A[i]: 0 <= i <= 99}\")\nD_X = isl.set(\"{X[i]: 0 <= i < 99}\")\ncorrect = A_X_A.intersect_domain(D_X).intersect_range(C_A)\nincorrect = A_X_A.intersect_domain(D_X).subtract(correct)\nprint_latex(incorrect)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"18":["","",""],"19":["### \nThe equation \\\\(1 = 0\\\\) is false.\nIn Presburger sets notation, it is used to express an empty set without loosing the name and dimension information.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>The equation \\(1 = 0\\) is false.\nIn Presburger sets notation, it is used to express an empty set without loosing the name and dimension information.</p>\n","markdown"],"20":["## Potentially Dependent Instances\nLet us first define the *inverse* access relation, which maps array elements to statement instances that access these elements.\nGiven the original access relation\n\\\\( \\\\mathcal{A}\\_{\\\\mathtt{S} \\\\\\\\rightarrow \\\\mathtt{Z}} = \\\\{ \\\\mathtt{S}(i) \\\\\\\\rightarrow \\\\mathtt{Z}(a):\n    a = i \\wedge 0 \\leq a,i \\leq 200 \\\\} \\\\),\nthe inverse relation is defined by the *same constraints* but with domain and range spaces are swapped,\n\\\\( \\\\mathcal{A}\\_{\\\\mathtt{S} \\\\\\\\rightarrow \\\\mathtt{Z}}^{-1} = \\\\{ \\\\mathtt{Z}(a) \\\\\\\\rightarrow \\\\mathtt{S}(i):\n    a = i \\wedge 0 \\leq a,i \\leq 200 \\\\} \\\\).\n*isl* can compute inverse relations using","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"potentiallydependentinstances\">Potentially Dependent Instances</h2>\n<p>Let us first define the <em>inverse</em> access relation, which maps array elements to statement instances that access these elements.\nGiven the original access relation\n\\( \\mathcal{A}_{\\mathtt{S} \\rightarrow \\mathtt{Z}} = \\{ \\mathtt{S}(i) \\rightarrow \\mathtt{Z}(a):\n    a = i \\wedge 0 \\leq a,i \\leq 200 \\} \\),\nthe inverse relation is defined by the <em>same constraints</em> but with domain and range spaces are swapped,\n\\( \\mathcal{A}_{\\mathtt{S} \\rightarrow \\mathtt{Z}}^{-1} = \\{ \\mathtt{Z}(a) \\rightarrow \\mathtt{S}(i):\n    a = i \\wedge 0 \\leq a,i \\leq 200 \\} \\).\n<em>isl</em> can compute inverse relations using</p>\n","markdown"],"21":["A_S_Z_inv = A_S_Z.reverse()\nprint_latex(A_S_Z_inv)","\\[\\{\\, \\mathrm{Z}(a) \\to \\mathrm{S}(i = a) \\mid 0 \\le a \\le 200 \\,\\}\\]\n","python"],"22":["### \nIf two statement instances access the *same* array element, they may interfere with each other.\nFor example, one instance may write the value that is later read by another instance.\n(In absence of `volatile` qualifier, two instances that *read* the same element are not supposed to interfere.)\nTranslating this definition into relations, we need to define a map between statement instances that access the same array elements.\nUsing the access relation, we know which elements a statement instance access.\nUsing the inverse access relation, we know which (other) statement instances access an array element.\nCombining the two relations and equating the array subscript parts will give us the relation between potentially dependent statement instances.\n\nThis can be achieved through relation composition,\n\\\\( \\\\mathcal{X} \\\\circ \\\\mathcal{Y} = \\\\{ \\\\pmb{x} \\\\\\\\rightarrow \\\\pmb{y} \\\\mid\n    \\\\exists \\\\pmb{z} : (\\\\pmb{x},\\\\pmb{z}) \\\\in \\\\mathcal{X} \\\\wedge (\\\\pmb{z},\\\\pmb{y}) \\\\in \\\\mathcal{Y} \\\\} \\\\).\n    \n*isl* lets you compose relations by applying a relation to the range of another relation.\nTo compute instances of `S` that access the same elements of `Z`, proceed as follows","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>If two statement instances access the <em>same</em> array element, they may interfere with each other.\nFor example, one instance may write the value that is later read by another instance.\n(In absence of <code>volatile</code> qualifier, two instances that <em>read</em> the same element are not supposed to interfere.)\nTranslating this definition into relations, we need to define a map between statement instances that access the same array elements.\nUsing the access relation, we know which elements a statement instance access.\nUsing the inverse access relation, we know which (other) statement instances access an array element.\nCombining the two relations and equating the array subscript parts will give us the relation between potentially dependent statement instances.</p>\n<p>This can be achieved through relation composition,\n\\( \\mathcal{X} \\circ \\mathcal{Y} = \\{ \\pmb{x} \\rightarrow \\pmb{y} \\mid\n    \\exists \\pmb{z} : (\\pmb{x},\\pmb{z}) \\in \\mathcal{X} \\wedge (\\pmb{z},\\pmb{y}) \\in \\mathcal{Y} \\} \\).</p>\n<p><em>isl</em> lets you compose relations by applying a relation to the range of another relation.\nTo compute instances of <code>S</code> that access the same elements of <code>Z</code>, proceed as follows</p>\n","markdown"],"23":["dep_S_Z = A_S_Z.apply_range(A_S_Z.reverse())\nprint_latex(dep_S_Z)","\\[\\{\\, \\mathrm{S}(i) \\to \\mathrm{S}(i' = i) \\mid 0 \\le i \\le 200 \\,\\}\\]\n","python"],"24":["### \nAs a result, you obtained a map between instances of `S`.\nIn this case, it is essentially a constrained *identity* relation due to \\\\(i^\\\\prime = i\\\\) equality.\nThis means that different instances of `S` access different array elements.\n\n### Question\nDefine a map `dep_S_zero` that connects instances of `S` accessing the `zero` variable.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>As a result, you obtained a map between instances of <code>S</code>.\nIn this case, it is essentially a constrained <em>identity</em> relation due to \\(i^\\prime = i\\) equality.\nThis means that different instances of <code>S</code> access different array elements.</p>\n<h3 id=\"question\">Question</h3>\n<p>Define a map <code>dep_S_zero</code> that connects instances of <code>S</code> accessing the <code>zero</code> variable.</p>\n","markdown"],"25":["#!Solution\ndep_S_zero = A_S_zero.apply_range(A_S_zero.reverse())\nprint_latex(dep_S_zero)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\ndep_S_zero = A_S_zero.apply_range(A_S_zero.reverse())\nprint_latex(dep_S_zero)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"26":["","","python"],"27":["### \nNow you see that all instances of `S` are related to each other because all of them access the scalar value.\nYet they only read this value and never modify it and thus should not interfere with each other.\n\n## Reads and Writes\nGenerally, only the cases where at least one access is a *write* are considered potentially dependent.\nTherefore, one needs to separate read and write accesses into different relations.\n\nLet us reproduce our running example with smaller sizes for illustrative purposes and after propagating the constant value `zero`.\n```c\ndouble X[10], Y[10], Z[20];\n\nfor (int i = 0; i <= 20; ++i)\nS:  Z[i] = 0.;\nfor (int i = 0; i <= 10; ++i)\n    for (int j = 0; j <= 10; ++j)\nT:      Z[i + j] += A[i] * B[j];\n```\n\nAs a side remark, for *isl*, the complexity depends on the number of constraints rather than the number of points in the set.\n\nBecause maps in a union can live in different spaces, one can define a map of all reads and all writes by combining individual access (union) maps from different statements.\n\n### Question\nGiven the individual access relations below, define union maps `reads` and `writes` for the *entire SCoP*.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Now you see that all instances of <code>S</code> are related to each other because all of them access the scalar value.\nYet they only read this value and never modify it and thus should not interfere with each other.</p>\n<h2 id=\"readsandwrites\">Reads and Writes</h2>\n<p>Generally, only the cases where at least one access is a <em>write</em> are considered potentially dependent.\nTherefore, one needs to separate read and write accesses into different relations.</p>\n<p>Let us reproduce our running example with smaller sizes for illustrative purposes and after propagating the constant value <code>zero</code>.</p>\n<pre><code class=\"c language-c\">double X[10], Y[10], Z[20];\n\nfor (int i = 0; i &lt;= 20; ++i)\nS:  Z[i] = 0.;\nfor (int i = 0; i &lt;= 10; ++i)\n    for (int j = 0; j &lt;= 10; ++j)\nT:      Z[i + j] += A[i] * B[j];\n</code></pre>\n<p>As a side remark, for <em>isl</em>, the complexity depends on the number of constraints rather than the number of points in the set.</p>\n<p>Because maps in a union can live in different spaces, one can define a map of all reads and all writes by combining individual access (union) maps from different statements.</p>\n<h3 id=\"question\">Question</h3>\n<p>Given the individual access relations below, define union maps <code>reads</code> and <code>writes</code> for the <em>entire SCoP</em>.</p>\n","markdown"],"28":["A_S_Z = isl.map(\"{S[i]->Z[a]: a = i and 0 <= a,i <= 20}\")\nA_T_Z = isl.map(\"{T[i,j]->Z[a]: a = i + j and 0 <= i,j <= 10 and 0 <= a <= 20}\")\nA_T_A = isl.map(\"{T[i,j]->A[a]: a = i and 0 <= a <= 20 and 0 <= i,j <= 10}\")\nA_T_B = isl.map(\"{T[i,j]->B[a]: a = j and 0 <= a <= 20 and 0 <= i,j <= 10}\")","","python"],"29":["#!Solution\nwrites = isl.union_map(A_S_Z).union(A_T_Z)\nreads = isl.union_map(A_T_Z).union(A_T_A).union(A_T_B)\nprint_latex(reads)\nprint_latex(writes)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nwrites = isl.union_map(A_S_Z).union(A_T_Z)\nreads = isl.union_map(A_T_Z).union(A_T_A).union(A_T_B)\nprint_latex(reads)\nprint_latex(writes)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"30":["","",""],"31":["## Selecting one Write\nTo avoid a composition the case when read accesses are composed with read accesses, we must ensure that\n`reads` does not appear simultaneously on both sides of the composition \n\\\\( (\\\\mathtt{reads} \\\\circ \\\\mathtt{writes}^{-1}) \\\\cup \n    (\\\\mathtt{writes} \\\\circ \\\\mathtt{reads}^{-1}) \\\\cup\n    (\\\\mathtt{writes} \\\\circ \\\\mathtt{writes}^{-1}) \\\\)\nNote that `writes` appears on the right hand side twice, so we can simplify the expression to\n\\\\( ((\\\\mathtt{reads} \\\\cup \\\\mathtt{writes}) \\\\circ \\\\mathtt{writes}^{-1}) \\\\cup (\\\\mathtt{writes} \\\\circ \\\\mathtt{reads}^{-1}) \\\\).\n\nLet us compute the first part of the union.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"selectingonewrite\">Selecting one Write</h2>\n<p>To avoid a composition the case when read accesses are composed with read accesses, we must ensure that\n<code>reads</code> does not appear simultaneously on both sides of the composition \n\\( (\\mathtt{reads} \\circ \\mathtt{writes}^{-1}) \\cup \n    (\\mathtt{writes} \\circ \\mathtt{reads}^{-1}) \\cup\n    (\\mathtt{writes} \\circ \\mathtt{writes}^{-1}) \\)\nNote that <code>writes</code> appears on the right hand side twice, so we can simplify the expression to\n\\( ((\\mathtt{reads} \\cup \\mathtt{writes}) \\circ \\mathtt{writes}^{-1}) \\cup (\\mathtt{writes} \\circ \\mathtt{reads}^{-1}) \\).</p>\n<p>Let us compute the first part of the union.</p>\n","markdown"],"32":["reads_writes = reads.union(writes)\nleft_part = reads_writes.apply_range(writes.reverse())\nprint_latex(left_part)","<div class='alert alert-danger' role='alert><span style='color: red'><strong>NameError</strong>: global name 'reads' is not defined</span><br><span style='color: black; text-decoration: underline; cursor: pointer' onclick='pt_toggleStackTraceVisibility(this)'>Show stack trace</span><div style='display: none; color: black'>Traceback (most recent call last):<br>  File \"c callback\", line 4, in &lt;module&gt;<br>  File \"&lt;string&gt;\", line 1, in &lt;module&gt;<br>NameError: global name 'reads' is not defined<br></div></div>","error"],"33":["### Question\nCompute the second part of the union and the entire union.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Compute the second part of the union and the entire union.</p>\n","markdown"],"34":["#!Solution\nright_part = writes.apply_range(reads.reverse())\nunion = left_part.union(right_part)\nprint_latex(union)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nright_part = writes.apply_range(reads.reverse())\nunion = left_part.union(right_part)\nprint_latex(union)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"35":["","",""],"36":["### Question:\nNow compute separately the `two_reads` relation that connects statement instances that read the same elements.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question:</h3>\n<p>Now compute separately the <code>two_reads</code> relation that connects statement instances that read the same elements.</p>\n","markdown"],"37":["#!Solution\ntwo_reads = reads.apply_range(reads.reverse())\nprint_latex(two_reads)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\ntwo_reads = reads.apply_range(reads.reverse())\nprint_latex(two_reads)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"38":["","",""],"39":["### \nLet's compare these relations.  Even if they are printed in a different order, `union` and `left_part` are exactly the same.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Let's compare these relations.  Even if they are printed in a different order, <code>union</code> and <code>left_part</code> are exactly the same.</p>\n","markdown"],"40":["print union.is_equal(left_part)","<div class='alert alert-danger' role='alert><span style='color: red'><strong>NameError</strong>: global name 'union' is not defined</span><br><span style='color: black; text-decoration: underline; cursor: pointer' onclick='pt_toggleStackTraceVisibility(this)'>Show stack trace</span><div style='display: none; color: black'>Traceback (most recent call last):<br>  File \"c callback\", line 2, in &lt;module&gt;<br>  File \"&lt;string&gt;\", line 1, in &lt;module&gt;<br>NameError: global name 'union' is not defined<br></div></div>","error"],"41":["### \nThis happens because the `left_part` is in fact a subset of `right_part` in our case.\nBecause `T` both reads and writes the same element,\nthe pair \\\\( \\\\mathtt{S}(i) \\\\\\\\rightarrow \\\\mathtt{T}(i',j=i-i') \\\\) will appear in both.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>This happens because the <code>left_part</code> is in fact a subset of <code>right_part</code> in our case.\nBecause <code>T</code> both reads and writes the same element,\nthe pair \\( \\mathtt{S}(i) \\rightarrow \\mathtt{T}(i',j=i-i') \\) will appear in both.</p>\n","markdown"],"42":["print right_part.is_subset(left_part)","<div class='alert alert-danger' role='alert><span style='color: red'><strong>NameError</strong>: global name 'right_part' is not defined</span><br><span style='color: black; text-decoration: underline; cursor: pointer' onclick='pt_toggleStackTraceVisibility(this)'>Show stack trace</span><div style='display: none; color: black'>Traceback (most recent call last):<br>  File \"c callback\", line 2, in &lt;module&gt;<br>  File \"&lt;string&gt;\", line 1, in &lt;module&gt;<br>NameError: global name 'right_part' is not defined<br></div></div>","error"],"43":["### \nTherefore, we could not just compute the overall set of potentially dependent statement pairs and then subtract\nthose with two reads.  If the same relation comes from two writes, it would also disappear!\n\n### Question\nCompute the relation between pairs of statement instances using both reads and writes,\nsubtract `two_reads` from it and check that it is indeed only a subset of `union`.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Therefore, we could not just compute the overall set of potentially dependent statement pairs and then subtract\nthose with two reads.  If the same relation comes from two writes, it would also disappear!</p>\n<h3 id=\"question\">Question</h3>\n<p>Compute the relation between pairs of statement instances using both reads and writes,\nsubtract <code>two_reads</code> from it and check that it is indeed only a subset of <code>union</code>.</p>\n","markdown"],"44":["#!Solution\nall_pairs = reads_writes.apply_range(reads_writes.reverse())\nall_pairs = all_pairs.subtract(two_reads)\nprint all_pairs.is_equal(union)\nprint all_pairs.is_subset(union)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nall_pairs = reads_writes.apply_range(reads_writes.reverse())\nall_pairs = all_pairs.subtract(two_reads)\nprint all_pairs.is_equal(union)\nprint all_pairs.is_subset(union)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"45":["","",""],"46":["## Visualizing Potentially Dependent Instances\nLet us constraint ourselves only to the instances of `T`.\nWe can use the fact that *isl* maps are *named* to select part of the union map.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h2 id=\"visualizingpotentiallydependentinstances\">Visualizing Potentially Dependent Instances</h2>\n<p>Let us constraint ourselves only to the instances of <code>T</code>.\nWe can use the fact that <em>isl</em> maps are <em>named</em> to select part of the union map.</p>\n","markdown"],"47":["T_only = isl.map(\"{T[i,j]->T[i,j]:}\")\nunion = union.intersect(T_only)\nprint_latex(union)\nplot(union)","<div class='alert alert-danger' role='alert><span style='color: red'><strong>NameError</strong>: global name 'union' is not defined</span><br><span style='color: black; text-decoration: underline; cursor: pointer' onclick='pt_toggleStackTraceVisibility(this)'>Show stack trace</span><div style='display: none; color: black'>Traceback (most recent call last):<br>  File \"c callback\", line 5, in &lt;module&gt;<br>  File \"&lt;string&gt;\", line 2, in &lt;module&gt;<br>NameError: global name 'union' is not defined<br></div></div>","error"],"48":["### \nAs you may see, each statement instance is related to *itself* and to one or multiple instances on the same diagonal.\n\n### Question \nDefine a map `left_42` that contains only the pairs where \\\\(\\\\mathtt{T}(4,2) \\\\) is on the left,\nand a map `right_42` that contains only the pairs where it is on the right.\n\n*Hint*: map domain and range are sets and can be acted upon.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>As you may see, each statement instance is related to <em>itself</em> and to one or multiple instances on the same diagonal.</p>\n<h3 id=\"question\">Question</h3>\n<p>Define a map <code>left_42</code> that contains only the pairs where \\(\\mathtt{T}(4,2) \\) is on the left,\nand a map <code>right_42</code> that contains only the pairs where it is on the right.</p>\n<p><em>Hint</em>: map domain and range are sets and can be acted upon.</p>\n","markdown"],"49":["#!Solution\nleft_42 = union.intersect_domain(isl.set(\"{T[i,j]: i = 4 and j = 2}\"))\nright_42 = union.intersect_range(isl.set(\"{T[i,j]: i = 4 and j = 2}\"))","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nleft_42 = union.intersect_domain(isl.set(\"{T[i,j]: i = 4 and j = 2}\"))\nright_42 = union.intersect_range(isl.set(\"{T[i,j]: i = 4 and j = 2}\"))</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"50":["","",""],"51":["### \nLet's compare these relations graphically.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>Let's compare these relations graphically.</p>\n","markdown"],"52":["#!Solution\nplot([left_42,right_42])","<div class=\"pt-solution\" style=\"display: none\">#!Solution\nplot([left_42,right_42])</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"53":["","",""],"54":["### \nAs you may see, the two relations are identical.\nThis is again due to the only access to `Z[i+j]` being both read and write.\nThe statement instance is connected to all other statement instances that access the same data.\n\nHowever, it does not necessarily create a *dependence*.  For example, depending on itself does not fully make sense.\nFor two statement instances to be *dependent*, one of them should be executed *before* another.\nThat is, the first statement either produces some data necessary for the second one, or uses some data that would be overwritten by the second one.\nDependence computation requires knowing the *order* of statement execution.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"\"> </h3>\n<p>As you may see, the two relations are identical.\nThis is again due to the only access to <code>Z[i+j]</code> being both read and write.\nThe statement instance is connected to all other statement instances that access the same data.</p>\n<p>However, it does not necessarily create a <em>dependence</em>.  For example, depending on itself does not fully make sense.\nFor two statement instances to be <em>dependent</em>, one of them should be executed <em>before</em> another.\nThat is, the first statement either produces some data necessary for the second one, or uses some data that would be overwritten by the second one.\nDependence computation requires knowing the <em>order</em> of statement execution.</p>\n","markdown"],"55":["### Question\nGiven the following code, compute and visualize pairs of statements that access the same array element,\nand at least one of the accesses is a write.\n*Hint:* use disjunction to encode different subscripts in different references to the same array.\n\n```c\nfor (i = 0; i < 6; ++i)\n  for (j = 0; j < 5; ++j)\nS1: X[i][j] = i * j;\nfor (i = 8; i < 13; ++i)\n  for (j = 11; j < 15; ++j)\nS2: Y[i][j] = X[i - 8][j - 10] - X[i - 7][j - 11];\n```","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Given the following code, compute and visualize pairs of statements that access the same array element,\nand at least one of the accesses is a write.\n<em>Hint:</em> use disjunction to encode different subscripts in different references to the same array.</p>\n<pre><code class=\"c language-c\">for (i = 0; i &lt; 6; ++i)\n  for (j = 0; j &lt; 5; ++j)\nS1: X[i][j] = i * j;\nfor (i = 8; i &lt; 13; ++i)\n  for (j = 11; j &lt; 15; ++j)\nS2: Y[i][j] = X[i - 8][j - 10] - X[i - 7][j - 11];\n</code></pre>\n","markdown"],"56":["#!Solution\ndomain = isl.union_set(\"{S1[i,j]: 0 <= i < 6 and 0 <= j < 5; S2[i,j]: 8 <= i < 13 and 11 <= j < 15}\")\nwrites = isl.union_map(\"{S1[i,j] -> X[a,b]: a = i and b = j; S2[i,j]->Y[a,b]: a = i and b = j}\")\nreads = isl.union_map(\"{S2[i,j] -> X[a,b]: (a = i - 8 and b = j - 10) or (a = i - 7 and b = j - 11)}\")\nwrites = writes.intersect_domain(domain)\nreads = reads.intersect_domain(domain)\ndeps = writes.apply_range(reads.reverse())\nprint_latex(deps)\nplot(deps)","<div class=\"pt-solution\" style=\"display: none\">#!Solution\ndomain = isl.union_set(\"{S1[i,j]: 0 <= i < 6 and 0 <= j < 5; S2[i,j]: 8 <= i < 13 and 11 <= j < 15}\")\nwrites = isl.union_map(\"{S1[i,j] -> X[a,b]: a = i and b = j; S2[i,j]->Y[a,b]: a = i and b = j}\")\nreads = isl.union_map(\"{S2[i,j] -> X[a,b]: (a = i - 8 and b = j - 10) or (a = i - 7 and b = j - 11)}\")\nwrites = writes.intersect_domain(domain)\nreads = reads.intersect_domain(domain)\ndeps = writes.apply_range(reads.reverse())\nprint_latex(deps)\nplot(deps)</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"57":["","",""],"58":["### Question\nSelect *sample* instances of `S1` and `S2` and plot the instances of other statement that access the same array element.","<a onclick='pt_editMarkdown(this)' tabindex='-1' class=\"pt-markdown-link\">[Markdown]</a><h3 id=\"question\">Question</h3>\n<p>Select <em>sample</em> instances of <code>S1</code> and <code>S2</code> and plot the instances of other statement that access the same array element.</p>\n","markdown"],"59":["#!Solution\npoint_22 = isl.set(\"{S1[i,j]: i = 2 and j = 2}\")\npoint_1012 = isl.set(\"{S2[i,j]: i = 10 and j = 12}\")\nsinks = deps.intersect_domain(point_22)\nsources = deps.intersect_range(point_1012)\nplot([sinks, sources])","<div class=\"pt-solution\" style=\"display: none\">#!Solution\npoint_22 = isl.set(\"{S1[i,j]: i = 2 and j = 2}\")\npoint_1012 = isl.set(\"{S2[i,j]: i = 10 and j = 12}\")\nsinks = deps.intersect_domain(point_22)\nsources = deps.intersect_range(point_1012)\nplot([sinks, sources])</div><a onclick='pt_fillInSolution(this)' tabindex='-1' class=\"pt-markdown-link\">[Solution]</a><br>\n","solution"],"60":["","",""]}